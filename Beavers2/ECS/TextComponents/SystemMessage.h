#pragma once
#include <iostream>
#include "Components.h"
#include "FontSheet.h"
//
// Алгоритм примерно такой: 
// 1. Создаем шрифт-лист из N букв и символов
//	1.1. Ширина окна под каждую букву фиксирована. 
//	1.2. Все буквы строчные, ибо я рот ебал. Буквы "с хвостиком" изначально чуть опущены. 
// 2. Пользуясь Димкиным способом при помощи шейдера получаем некие прямоугольники с буквами внутри. 
//	2.1. При помощи шейдера нужно как-то вырезать из большого изображения маленькое (w на h), получив координаты вершин прямоугольника путем
//			деления с остатком.  
//	2.2. Эти прямоугольники нужно в соответствии со строкой разместить в карту/словарь, поставив в соответствие некий индекс или char.
//	2.3. Адресуемся через карту, используя в качестве адресов символы строки сообщения.
// 3. Размещаем прямоугольник в указанной позиции на экране, после чего размещаем следующий на позиции с x+a абсциссами, где a - ширина буквы
//	3.1. Предположительно, вырезанную шейдером букву передаем OpenGL как текстуру для полигона общегно вида
//			h - высота буквы
//			w - ширина буквы
//			sx - позиция буквы в строке по горизонтали
//			sy - номер строки
//			[w*(sx-1), h*sy,     0, 0,
//			 w*(sx),   h*sy,     1, 0,
//			 w*(sx),   h*(sy-1), 1, 1, 
//			 w*(sx-1), h*(sy-1), 0, 1]
//	3.2. Красить буквы можно все тем же шейдером, главное только разобраться, как в пределах одной строки покрасить разные слова в разные
//			цвета. Прикрутим к тексту анимацию - плюсик в карму, но за байт у "катаны зеро" могут и на ротан дать, так что тут осторожно.
class SystemMessage : public Component
{
private:
	std::string message;
	FontSheet* fontsheet;
	std::map<char, int> indexes_map; //ТОЛЬКО В ЛАТИНИЦЕ МОЖНО ПРОСТО ТАК ВЗЯТЬ И int index = char - '0' - 48 :(((
public: 
	SystemMessage(std::string cur_message, FontSheet* cur_fs);
};